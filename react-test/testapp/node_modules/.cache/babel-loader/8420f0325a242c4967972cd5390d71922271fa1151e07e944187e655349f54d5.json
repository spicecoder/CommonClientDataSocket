{"ast":null,"code":"var _jsxFileName = \"/Users/pronabpal/QuickLab/praxis-hub-demo/ClientServer_Pulse/jsoncpux-runtime-core-updated/forclaude-enhanced/Algebraic_IntentionSpace/WebSocketDataRepo/react-test/testapp/src/use_websocket_data_hook.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$();\n// useWebSocketData.js - React Hook for WebSocket Data Client\nimport { useState, useEffect, useRef, useCallback, useContext, createContext } from 'react';\n\n// Create WebSocket Data Context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WebSocketDataContext = /*#__PURE__*/createContext(null);\n\n// WebSocket Data Provider Component\nexport function WebSocketDataProvider({\n  children,\n  serverUrl,\n  options = {}\n}) {\n  _s();\n  const clientRef = useRef(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isReady, setIsReady] = useState(false);\n  const [error, setError] = useState(null);\n  const [clientInfo, setClientInfo] = useState(null);\n  useEffect(() => {\n    let WebSocketDataClient;\n\n    // Dynamic import based on platform\n    const initializeClient = async () => {\n      try {\n        // For React Native, you'll import directly\n        if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n          // In React Native, you would import like this:\n          // WebSocketDataClient = require('./WebSocketDataClient');\n          console.log('React Native environment detected');\n        } else if (typeof window !== 'undefined') {\n          // Browser environment\n          WebSocketDataClient = window.WebSocketDataClient;\n          if (!WebSocketDataClient) {\n            throw new Error('WebSocketDataClient not found. Please include the script.');\n          }\n        } else {\n          // Node.js environment (for testing)\n          WebSocketDataClient = require('./websocket_data_client');\n        }\n\n        // Initialize client\n        clientRef.current = new WebSocketDataClient({\n          serverUrl: serverUrl || 'ws://localhost:8081',\n          ...options\n        });\n\n        // Set up event listeners\n        clientRef.current.on('connected', () => {\n          console.log('🔌 WebSocket Data Provider connected');\n          setIsConnected(true);\n          setError(null);\n        });\n        clientRef.current.on('ready', info => {\n          console.log('✅ WebSocket Data Provider ready');\n          setIsReady(true);\n          setClientInfo(info);\n        });\n        clientRef.current.on('disconnected', info => {\n          console.log('🔌 WebSocket Data Provider disconnected');\n          setIsConnected(false);\n          setIsReady(false);\n          setError(new Error(`Disconnected: ${info.reason}`));\n        });\n        clientRef.current.on('error', err => {\n          console.error('❌ WebSocket Data Provider error:', err);\n          setError(err);\n        });\n        clientRef.current.on('maxReconnectAttemptsReached', () => {\n          setError(new Error('Failed to reconnect to server'));\n        });\n\n        // Connect to server\n        await clientRef.current.connect();\n      } catch (err) {\n        console.error('💥 Failed to initialize WebSocket Data Client:', err);\n        setError(err);\n      }\n    };\n    initializeClient();\n\n    // Cleanup on unmount\n    return () => {\n      if (clientRef.current) {\n        clientRef.current.disconnect();\n      }\n    };\n  }, [serverUrl]);\n  const contextValue = {\n    client: clientRef.current,\n    isConnected,\n    isReady,\n    error,\n    clientInfo\n  };\n  return /*#__PURE__*/_jsxDEV(WebSocketDataContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 100,\n    columnNumber: 5\n  }, this);\n}\n\n// Main Hook for using WebSocket Data\n_s(WebSocketDataProvider, \"ZK/WrMskPtYcSTcXrb6HaOlZwhM=\");\n_c = WebSocketDataProvider;\nexport function useWebSocketData() {\n  _s2();\n  const context = useContext(WebSocketDataContext);\n  if (!context) {\n    throw new Error('useWebSocketData must be used within a WebSocketDataProvider');\n  }\n  const {\n    client,\n    isConnected,\n    isReady,\n    error\n  } = context;\n\n  // State for loading operations\n  const [loading, setLoading] = useState(false);\n  const [lastError, setLastError] = useState(null);\n\n  // Generic operation wrapper with error handling and loading state\n  const executeOperation = useCallback(async operation => {\n    if (!client || !isReady) {\n      throw new Error('WebSocket client not ready');\n    }\n    setLoading(true);\n    setLastError(null);\n    try {\n      const result = await operation(client);\n      return result;\n    } catch (err) {\n      setLastError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [client, isReady]);\n\n  // Get data\n  const getData = useCallback(async (collection, key, options = {}) => {\n    return executeOperation(async client => {\n      return await client.get(collection, key, options);\n    });\n  }, [executeOperation]);\n\n  // Set data\n  const setData = useCallback(async (collection, key, value, options = {}) => {\n    return executeOperation(async client => {\n      return await client.set(collection, key, value, options);\n    });\n  }, [executeOperation]);\n\n  // Delete data\n  const deleteData = useCallback(async (collection, key, options = {}) => {\n    return executeOperation(async client => {\n      return await client.delete(collection, key, options);\n    });\n  }, [executeOperation]);\n\n  // Query data\n  const queryData = useCallback(async (collection, query, options = {}) => {\n    return executeOperation(async client => {\n      return await client.query(collection, query, options);\n    });\n  }, [executeOperation]);\n\n  // Batch operations\n  const batchOperations = useCallback(async operations => {\n    return executeOperation(async client => {\n      return await client.batch(operations);\n    });\n  }, [executeOperation]);\n\n  // Subscribe to data changes\n  const subscribe = useCallback(async (collection, pattern, callback) => {\n    if (!client || !isReady) {\n      throw new Error('WebSocket client not ready');\n    }\n    return await client.subscribe(collection, pattern, callback);\n  }, [client, isReady]);\n\n  // Unsubscribe from data changes\n  const unsubscribe = useCallback(async (collection, pattern) => {\n    if (!client || !isReady) {\n      throw new Error('WebSocket client not ready');\n    }\n    return await client.unsubscribe(collection, pattern);\n  }, [client, isReady]);\n  return {\n    // Connection status\n    isConnected,\n    isReady,\n    error: error || lastError,\n    loading,\n    client,\n    // Data operations\n    getData,\n    setData,\n    deleteData,\n    queryData,\n    batchOperations,\n    // Real-time subscriptions\n    subscribe,\n    unsubscribe\n  };\n}\n\n// Specialized Hook for Cart Data\n_s2(useWebSocketData, \"Clzn4V8sE+5EQ+KiXhA/KyBHIfQ=\");\nexport function useCartData(userId) {\n  _s3();\n  const {\n    getData,\n    setData,\n    deleteData,\n    subscribe,\n    unsubscribe,\n    isReady\n  } = useWebSocketData();\n  const [cart, setCart] = useState(null);\n  const [cartLoading, setCartLoading] = useState(false);\n  const [cartError, setCartError] = useState(null);\n\n  // Load cart on mount\n  useEffect(() => {\n    if (isReady && userId) {\n      loadCart();\n    }\n  }, [isReady, userId]);\n\n  // Subscribe to cart changes\n  useEffect(() => {\n    if (isReady && userId) {\n      const handleCartUpdate = update => {\n        if (update.key === userId && update.operation === 'SET') {\n          setCart(update.value);\n          console.log('🛒 Cart updated via subscription:', update.value);\n        }\n      };\n      subscribe('cart', userId, handleCartUpdate).catch(console.error);\n      return () => {\n        unsubscribe('cart', userId).catch(console.error);\n      };\n    }\n  }, [isReady, userId, subscribe, unsubscribe]);\n  const loadCart = useCallback(async () => {\n    if (!userId) return;\n    setCartLoading(true);\n    setCartError(null);\n    try {\n      const cartData = await getData('cart', userId, {\n        useIndexedDB: true\n      });\n      setCart(cartData || {\n        items: [],\n        total: 0\n      });\n    } catch (error) {\n      console.error('Failed to load cart:', error);\n      setCartError(error);\n      setCart({\n        items: [],\n        total: 0\n      }); // Fallback empty cart\n    } finally {\n      setCartLoading(false);\n    }\n  }, [userId, getData]);\n  const saveCart = useCallback(async cartData => {\n    if (!userId) throw new Error('User ID required');\n    setCartLoading(true);\n    setCartError(null);\n    try {\n      await setData('cart', userId, cartData, {\n        useIndexedDB: true\n      });\n      setCart(cartData);\n      console.log('💾 Cart saved successfully');\n    } catch (error) {\n      console.error('Failed to save cart:', error);\n      setCartError(error);\n      throw error;\n    } finally {\n      setCartLoading(false);\n    }\n  }, [userId, setData]);\n  const clearCart = useCallback(async () => {\n    if (!userId) throw new Error('User ID required');\n    const emptyCart = {\n      items: [],\n      total: 0\n    };\n    await saveCart(emptyCart);\n  }, [userId, saveCart]);\n  const addToCart = useCallback(async item => {\n    if (!cart) return;\n    const existingItemIndex = cart.items.findIndex(cartItem => cartItem.id === item.id);\n    let updatedItems;\n    if (existingItemIndex >= 0) {\n      // Update existing item\n      updatedItems = [...cart.items];\n      updatedItems[existingItemIndex] = {\n        ...updatedItems[existingItemIndex],\n        quantity: updatedItems[existingItemIndex].quantity + (item.quantity || 1)\n      };\n    } else {\n      // Add new item\n      updatedItems = [...cart.items, {\n        ...item,\n        quantity: item.quantity || 1\n      }];\n    }\n    const updatedCart = {\n      ...cart,\n      items: updatedItems,\n      total: updatedItems.reduce((sum, item) => sum + item.price * item.quantity, 0)\n    };\n    await saveCart(updatedCart);\n  }, [cart, saveCart]);\n  const removeFromCart = useCallback(async itemId => {\n    if (!cart) return;\n    const updatedItems = cart.items.filter(item => item.id !== itemId);\n    const updatedCart = {\n      ...cart,\n      items: updatedItems,\n      total: updatedItems.reduce((sum, item) => sum + item.price * item.quantity, 0)\n    };\n    await saveCart(updatedCart);\n  }, [cart, saveCart]);\n  return {\n    cart,\n    loading: cartLoading,\n    error: cartError,\n    loadCart,\n    saveCart,\n    clearCart,\n    addToCart,\n    removeFromCart\n  };\n}\n\n// Specialized Hook for User Session\n_s3(useCartData, \"FvjIyMtvnijtCbU+qI4RwqFYm5Q=\", false, function () {\n  return [useWebSocketData];\n});\nexport function useUserSession() {\n  _s4();\n  const {\n    getData,\n    setData,\n    deleteData,\n    isReady\n  } = useWebSocketData();\n  const [session, setSession] = useState(null);\n  const [sessionLoading, setSessionLoading] = useState(false);\n  const [sessionError, setSessionError] = useState(null);\n  const loadSession = useCallback(async userId => {\n    setSessionLoading(true);\n    setSessionError(null);\n    try {\n      const sessionData = await getData('sessions', userId);\n      setSession(sessionData);\n      return sessionData;\n    } catch (error) {\n      console.error('Failed to load session:', error);\n      setSessionError(error);\n      return null;\n    } finally {\n      setSessionLoading(false);\n    }\n  }, [getData]);\n  const saveSession = useCallback(async (userId, sessionData) => {\n    setSessionLoading(true);\n    setSessionError(null);\n    try {\n      await setData('sessions', userId, {\n        ...sessionData,\n        lastUpdated: Date.now()\n      });\n      setSession(sessionData);\n      console.log('💾 Session saved successfully');\n    } catch (error) {\n      console.error('Failed to save session:', error);\n      setSessionError(error);\n      throw error;\n    } finally {\n      setSessionLoading(false);\n    }\n  }, [setData]);\n  const clearSession = useCallback(async userId => {\n    try {\n      await deleteData('sessions', userId);\n      setSession(null);\n      console.log('🗑️ Session cleared successfully');\n    } catch (error) {\n      console.error('Failed to clear session:', error);\n      throw error;\n    }\n  }, [deleteData]);\n  return {\n    session,\n    loading: sessionLoading,\n    error: sessionError,\n    loadSession,\n    saveSession,\n    clearSession,\n    isReady\n  };\n}\n\n// Specialized Hook for Chat Messages\n_s4(useUserSession, \"WdYl8VfBTk2xe/JZjVyJcbjewJM=\", false, function () {\n  return [useWebSocketData];\n});\nexport function useChatData(roomId) {\n  _s5();\n  const {\n    getData,\n    setData,\n    subscribe,\n    unsubscribe,\n    isReady\n  } = useWebSocketData();\n  const [messages, setMessages] = useState([]);\n  const [chatLoading, setChatLoading] = useState(false);\n  const [chatError, setChatError] = useState(null);\n\n  // Load messages on mount\n  useEffect(() => {\n    if (isReady && roomId) {\n      loadMessages();\n    }\n  }, [isReady, roomId]);\n\n  // Subscribe to new messages\n  useEffect(() => {\n    if (isReady && roomId) {\n      const handleMessageUpdate = update => {\n        if (update.key === roomId && update.operation === 'SET') {\n          setMessages(update.value || []);\n          console.log('💬 Messages updated via subscription');\n        }\n      };\n      subscribe('chats', roomId, handleMessageUpdate).catch(console.error);\n      return () => {\n        unsubscribe('chats', roomId).catch(console.error);\n      };\n    }\n  }, [isReady, roomId, subscribe, unsubscribe]);\n  const loadMessages = useCallback(async () => {\n    if (!roomId) return;\n    setChatLoading(true);\n    setChatError(null);\n    try {\n      const messageData = await getData('chats', roomId, {\n        useIndexedDB: true,\n        useSQLite: true\n      });\n      setMessages(messageData || []);\n    } catch (error) {\n      console.error('Failed to load messages:', error);\n      setChatError(error);\n      setMessages([]);\n    } finally {\n      setChatLoading(false);\n    }\n  }, [roomId, getData]);\n  const sendMessage = useCallback(async message => {\n    if (!roomId) throw new Error('Room ID required');\n    const newMessage = {\n      id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      roomId,\n      content: message.content,\n      senderId: message.senderId,\n      timestamp: Date.now(),\n      type: message.type || 'text',\n      ...message\n    };\n    const updatedMessages = [...messages, newMessage];\n    try {\n      await setData('chats', roomId, updatedMessages, {\n        useIndexedDB: true,\n        useSQLite: true\n      });\n      console.log('💬 Message sent successfully');\n    } catch (error) {\n      console.error('Failed to send message:', error);\n      throw error;\n    }\n  }, [roomId, messages, setData]);\n  return {\n    messages,\n    loading: chatLoading,\n    error: chatError,\n    loadMessages,\n    sendMessage\n  };\n}\n_s5(useChatData, \"iUeYyEjTltYXs0WdP2gceN3QnDQ=\", false, function () {\n  return [useWebSocketData];\n});\nexport default useWebSocketData;\nvar _c;\n$RefreshReg$(_c, \"WebSocketDataProvider\");","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useContext","createContext","jsxDEV","_jsxDEV","WebSocketDataContext","WebSocketDataProvider","children","serverUrl","options","_s","clientRef","isConnected","setIsConnected","isReady","setIsReady","error","setError","clientInfo","setClientInfo","WebSocketDataClient","initializeClient","navigator","product","console","log","window","Error","require","current","on","info","reason","err","connect","disconnect","contextValue","client","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useWebSocketData","_s2","context","loading","setLoading","lastError","setLastError","executeOperation","operation","result","getData","collection","key","get","setData","set","deleteData","delete","queryData","query","batchOperations","operations","batch","subscribe","pattern","callback","unsubscribe","useCartData","userId","_s3","cart","setCart","cartLoading","setCartLoading","cartError","setCartError","loadCart","handleCartUpdate","update","catch","cartData","useIndexedDB","items","total","saveCart","clearCart","emptyCart","addToCart","item","existingItemIndex","findIndex","cartItem","id","updatedItems","quantity","updatedCart","reduce","sum","price","removeFromCart","itemId","filter","useUserSession","_s4","session","setSession","sessionLoading","setSessionLoading","sessionError","setSessionError","loadSession","sessionData","saveSession","lastUpdated","Date","now","clearSession","useChatData","roomId","_s5","messages","setMessages","chatLoading","setChatLoading","chatError","setChatError","loadMessages","handleMessageUpdate","messageData","useSQLite","sendMessage","message","newMessage","Math","random","toString","substr","content","senderId","timestamp","type","updatedMessages","$RefreshReg$"],"sources":["/Users/pronabpal/QuickLab/praxis-hub-demo/ClientServer_Pulse/jsoncpux-runtime-core-updated/forclaude-enhanced/Algebraic_IntentionSpace/WebSocketDataRepo/react-test/testapp/src/use_websocket_data_hook.js"],"sourcesContent":["// useWebSocketData.js - React Hook for WebSocket Data Client\nimport { useState, useEffect, useRef, useCallback, useContext, createContext } from 'react';\n\n// Create WebSocket Data Context\nconst WebSocketDataContext = createContext(null);\n\n// WebSocket Data Provider Component\nexport function WebSocketDataProvider({ children, serverUrl, options = {} }) {\n  const clientRef = useRef(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isReady, setIsReady] = useState(false);\n  const [error, setError] = useState(null);\n  const [clientInfo, setClientInfo] = useState(null);\n\n  useEffect(() => {\n    let WebSocketDataClient;\n\n    // Dynamic import based on platform\n    const initializeClient = async () => {\n      try {\n        // For React Native, you'll import directly\n        if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n          // In React Native, you would import like this:\n          // WebSocketDataClient = require('./WebSocketDataClient');\n          console.log('React Native environment detected');\n        } else if (typeof window !== 'undefined') {\n          // Browser environment\n          WebSocketDataClient = window.WebSocketDataClient;\n          if (!WebSocketDataClient) {\n            throw new Error('WebSocketDataClient not found. Please include the script.');\n          }\n        } else {\n          // Node.js environment (for testing)\n          WebSocketDataClient = require('./websocket_data_client');\n        }\n\n        // Initialize client\n        clientRef.current = new WebSocketDataClient({\n          serverUrl: serverUrl || 'ws://localhost:8081',\n          ...options\n        });\n\n        // Set up event listeners\n        clientRef.current.on('connected', () => {\n          console.log('🔌 WebSocket Data Provider connected');\n          setIsConnected(true);\n          setError(null);\n        });\n\n        clientRef.current.on('ready', (info) => {\n          console.log('✅ WebSocket Data Provider ready');\n          setIsReady(true);\n          setClientInfo(info);\n        });\n\n        clientRef.current.on('disconnected', (info) => {\n          console.log('🔌 WebSocket Data Provider disconnected');\n          setIsConnected(false);\n          setIsReady(false);\n          setError(new Error(`Disconnected: ${info.reason}`));\n        });\n\n        clientRef.current.on('error', (err) => {\n          console.error('❌ WebSocket Data Provider error:', err);\n          setError(err);\n        });\n\n        clientRef.current.on('maxReconnectAttemptsReached', () => {\n          setError(new Error('Failed to reconnect to server'));\n        });\n\n        // Connect to server\n        await clientRef.current.connect();\n\n      } catch (err) {\n        console.error('💥 Failed to initialize WebSocket Data Client:', err);\n        setError(err);\n      }\n    };\n\n    initializeClient();\n\n    // Cleanup on unmount\n    return () => {\n      if (clientRef.current) {\n        clientRef.current.disconnect();\n      }\n    };\n  }, [serverUrl]);\n\n  const contextValue = {\n    client: clientRef.current,\n    isConnected,\n    isReady,\n    error,\n    clientInfo\n  };\n\n  return (\n    <WebSocketDataContext.Provider value={contextValue}>\n      {children}\n    </WebSocketDataContext.Provider>\n  );\n}\n\n// Main Hook for using WebSocket Data\nexport function useWebSocketData() {\n  const context = useContext(WebSocketDataContext);\n  \n  if (!context) {\n    throw new Error('useWebSocketData must be used within a WebSocketDataProvider');\n  }\n\n  const { client, isConnected, isReady, error } = context;\n\n  // State for loading operations\n  const [loading, setLoading] = useState(false);\n  const [lastError, setLastError] = useState(null);\n\n  // Generic operation wrapper with error handling and loading state\n  const executeOperation = useCallback(async (operation) => {\n    if (!client || !isReady) {\n      throw new Error('WebSocket client not ready');\n    }\n\n    setLoading(true);\n    setLastError(null);\n\n    try {\n      const result = await operation(client);\n      return result;\n    } catch (err) {\n      setLastError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [client, isReady]);\n\n  // Get data\n  const getData = useCallback(async (collection, key, options = {}) => {\n    return executeOperation(async (client) => {\n      return await client.get(collection, key, options);\n    });\n  }, [executeOperation]);\n\n  // Set data\n  const setData = useCallback(async (collection, key, value, options = {}) => {\n    return executeOperation(async (client) => {\n      return await client.set(collection, key, value, options);\n    });\n  }, [executeOperation]);\n\n  // Delete data\n  const deleteData = useCallback(async (collection, key, options = {}) => {\n    return executeOperation(async (client) => {\n      return await client.delete(collection, key, options);\n    });\n  }, [executeOperation]);\n\n  // Query data\n  const queryData = useCallback(async (collection, query, options = {}) => {\n    return executeOperation(async (client) => {\n      return await client.query(collection, query, options);\n    });\n  }, [executeOperation]);\n\n  // Batch operations\n  const batchOperations = useCallback(async (operations) => {\n    return executeOperation(async (client) => {\n      return await client.batch(operations);\n    });\n  }, [executeOperation]);\n\n  // Subscribe to data changes\n  const subscribe = useCallback(async (collection, pattern, callback) => {\n    if (!client || !isReady) {\n      throw new Error('WebSocket client not ready');\n    }\n    return await client.subscribe(collection, pattern, callback);\n  }, [client, isReady]);\n\n  // Unsubscribe from data changes\n  const unsubscribe = useCallback(async (collection, pattern) => {\n    if (!client || !isReady) {\n      throw new Error('WebSocket client not ready');\n    }\n    return await client.unsubscribe(collection, pattern);\n  }, [client, isReady]);\n\n  return {\n    // Connection status\n    isConnected,\n    isReady,\n    error: error || lastError,\n    loading,\n    client,\n    \n    // Data operations\n    getData,\n    setData,\n    deleteData,\n    queryData,\n    batchOperations,\n    \n    // Real-time subscriptions\n    subscribe,\n    unsubscribe\n  };\n}\n\n// Specialized Hook for Cart Data\nexport function useCartData(userId) {\n  const { getData, setData, deleteData, subscribe, unsubscribe, isReady } = useWebSocketData();\n  const [cart, setCart] = useState(null);\n  const [cartLoading, setCartLoading] = useState(false);\n  const [cartError, setCartError] = useState(null);\n\n  // Load cart on mount\n  useEffect(() => {\n    if (isReady && userId) {\n      loadCart();\n    }\n  }, [isReady, userId]);\n\n  // Subscribe to cart changes\n  useEffect(() => {\n    if (isReady && userId) {\n      const handleCartUpdate = (update) => {\n        if (update.key === userId && update.operation === 'SET') {\n          setCart(update.value);\n          console.log('🛒 Cart updated via subscription:', update.value);\n        }\n      };\n\n      subscribe('cart', userId, handleCartUpdate).catch(console.error);\n\n      return () => {\n        unsubscribe('cart', userId).catch(console.error);\n      };\n    }\n  }, [isReady, userId, subscribe, unsubscribe]);\n\n  const loadCart = useCallback(async () => {\n    if (!userId) return;\n\n    setCartLoading(true);\n    setCartError(null);\n\n    try {\n      const cartData = await getData('cart', userId, { useIndexedDB: true });\n      setCart(cartData || { items: [], total: 0 });\n    } catch (error) {\n      console.error('Failed to load cart:', error);\n      setCartError(error);\n      setCart({ items: [], total: 0 }); // Fallback empty cart\n    } finally {\n      setCartLoading(false);\n    }\n  }, [userId, getData]);\n\n  const saveCart = useCallback(async (cartData) => {\n    if (!userId) throw new Error('User ID required');\n\n    setCartLoading(true);\n    setCartError(null);\n\n    try {\n      await setData('cart', userId, cartData, { useIndexedDB: true });\n      setCart(cartData);\n      console.log('💾 Cart saved successfully');\n    } catch (error) {\n      console.error('Failed to save cart:', error);\n      setCartError(error);\n      throw error;\n    } finally {\n      setCartLoading(false);\n    }\n  }, [userId, setData]);\n\n  const clearCart = useCallback(async () => {\n    if (!userId) throw new Error('User ID required');\n\n    const emptyCart = { items: [], total: 0 };\n    await saveCart(emptyCart);\n  }, [userId, saveCart]);\n\n  const addToCart = useCallback(async (item) => {\n    if (!cart) return;\n\n    const existingItemIndex = cart.items.findIndex(cartItem => cartItem.id === item.id);\n    let updatedItems;\n\n    if (existingItemIndex >= 0) {\n      // Update existing item\n      updatedItems = [...cart.items];\n      updatedItems[existingItemIndex] = {\n        ...updatedItems[existingItemIndex],\n        quantity: updatedItems[existingItemIndex].quantity + (item.quantity || 1)\n      };\n    } else {\n      // Add new item\n      updatedItems = [...cart.items, { ...item, quantity: item.quantity || 1 }];\n    }\n\n    const updatedCart = {\n      ...cart,\n      items: updatedItems,\n      total: updatedItems.reduce((sum, item) => sum + (item.price * item.quantity), 0)\n    };\n\n    await saveCart(updatedCart);\n  }, [cart, saveCart]);\n\n  const removeFromCart = useCallback(async (itemId) => {\n    if (!cart) return;\n\n    const updatedItems = cart.items.filter(item => item.id !== itemId);\n    const updatedCart = {\n      ...cart,\n      items: updatedItems,\n      total: updatedItems.reduce((sum, item) => sum + (item.price * item.quantity), 0)\n    };\n\n    await saveCart(updatedCart);\n  }, [cart, saveCart]);\n\n  return {\n    cart,\n    loading: cartLoading,\n    error: cartError,\n    loadCart,\n    saveCart,\n    clearCart,\n    addToCart,\n    removeFromCart\n  };\n}\n\n// Specialized Hook for User Session\nexport function useUserSession() {\n  const { getData, setData, deleteData, isReady } = useWebSocketData();\n  const [session, setSession] = useState(null);\n  const [sessionLoading, setSessionLoading] = useState(false);\n  const [sessionError, setSessionError] = useState(null);\n\n  const loadSession = useCallback(async (userId) => {\n    setSessionLoading(true);\n    setSessionError(null);\n\n    try {\n      const sessionData = await getData('sessions', userId);\n      setSession(sessionData);\n      return sessionData;\n    } catch (error) {\n      console.error('Failed to load session:', error);\n      setSessionError(error);\n      return null;\n    } finally {\n      setSessionLoading(false);\n    }\n  }, [getData]);\n\n  const saveSession = useCallback(async (userId, sessionData) => {\n    setSessionLoading(true);\n    setSessionError(null);\n\n    try {\n      await setData('sessions', userId, {\n        ...sessionData,\n        lastUpdated: Date.now()\n      });\n      setSession(sessionData);\n      console.log('💾 Session saved successfully');\n    } catch (error) {\n      console.error('Failed to save session:', error);\n      setSessionError(error);\n      throw error;\n    } finally {\n      setSessionLoading(false);\n    }\n  }, [setData]);\n\n  const clearSession = useCallback(async (userId) => {\n    try {\n      await deleteData('sessions', userId);\n      setSession(null);\n      console.log('🗑️ Session cleared successfully');\n    } catch (error) {\n      console.error('Failed to clear session:', error);\n      throw error;\n    }\n  }, [deleteData]);\n\n  return {\n    session,\n    loading: sessionLoading,\n    error: sessionError,\n    loadSession,\n    saveSession,\n    clearSession,\n    isReady\n  };\n}\n\n// Specialized Hook for Chat Messages\nexport function useChatData(roomId) {\n  const { getData, setData, subscribe, unsubscribe, isReady } = useWebSocketData();\n  const [messages, setMessages] = useState([]);\n  const [chatLoading, setChatLoading] = useState(false);\n  const [chatError, setChatError] = useState(null);\n\n  // Load messages on mount\n  useEffect(() => {\n    if (isReady && roomId) {\n      loadMessages();\n    }\n  }, [isReady, roomId]);\n\n  // Subscribe to new messages\n  useEffect(() => {\n    if (isReady && roomId) {\n      const handleMessageUpdate = (update) => {\n        if (update.key === roomId && update.operation === 'SET') {\n          setMessages(update.value || []);\n          console.log('💬 Messages updated via subscription');\n        }\n      };\n\n      subscribe('chats', roomId, handleMessageUpdate).catch(console.error);\n\n      return () => {\n        unsubscribe('chats', roomId).catch(console.error);\n      };\n    }\n  }, [isReady, roomId, subscribe, unsubscribe]);\n\n  const loadMessages = useCallback(async () => {\n    if (!roomId) return;\n\n    setChatLoading(true);\n    setChatError(null);\n\n    try {\n      const messageData = await getData('chats', roomId, {\n        useIndexedDB: true,\n        useSQLite: true\n      });\n      setMessages(messageData || []);\n    } catch (error) {\n      console.error('Failed to load messages:', error);\n      setChatError(error);\n      setMessages([]);\n    } finally {\n      setChatLoading(false);\n    }\n  }, [roomId, getData]);\n\n  const sendMessage = useCallback(async (message) => {\n    if (!roomId) throw new Error('Room ID required');\n\n    const newMessage = {\n      id: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      roomId,\n      content: message.content,\n      senderId: message.senderId,\n      timestamp: Date.now(),\n      type: message.type || 'text',\n      ...message\n    };\n\n    const updatedMessages = [...messages, newMessage];\n\n    try {\n      await setData('chats', roomId, updatedMessages, {\n        useIndexedDB: true,\n        useSQLite: true\n      });\n      console.log('💬 Message sent successfully');\n    } catch (error) {\n      console.error('Failed to send message:', error);\n      throw error;\n    }\n  }, [roomId, messages, setData]);\n\n  return {\n    messages,\n    loading: chatLoading,\n    error: chatError,\n    loadMessages,\n    sendMessage\n  };\n}\n\nexport default useWebSocketData;"],"mappings":";;;;;;AAAA;AACA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,MAAM,EAAEC,WAAW,EAAEC,UAAU,EAAEC,aAAa,QAAQ,OAAO;;AAE3F;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,oBAAoB,gBAAGH,aAAa,CAAC,IAAI,CAAC;;AAEhD;AACA,OAAO,SAASI,qBAAqBA,CAAC;EAAEC,QAAQ;EAAEC,SAAS;EAAEC,OAAO,GAAG,CAAC;AAAE,CAAC,EAAE;EAAAC,EAAA;EAC3E,MAAMC,SAAS,GAAGZ,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAM,CAACa,WAAW,EAAEC,cAAc,CAAC,GAAGhB,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACiB,OAAO,EAAEC,UAAU,CAAC,GAAGlB,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAM,CAACmB,KAAK,EAAEC,QAAQ,CAAC,GAAGpB,QAAQ,CAAC,IAAI,CAAC;EACxC,MAAM,CAACqB,UAAU,EAAEC,aAAa,CAAC,GAAGtB,QAAQ,CAAC,IAAI,CAAC;EAElDC,SAAS,CAAC,MAAM;IACd,IAAIsB,mBAAmB;;IAEvB;IACA,MAAMC,gBAAgB,GAAG,MAAAA,CAAA,KAAY;MACnC,IAAI;QACF;QACA,IAAI,OAAOC,SAAS,KAAK,WAAW,IAAIA,SAAS,CAACC,OAAO,KAAK,aAAa,EAAE;UAC3E;UACA;UACAC,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;QAClD,CAAC,MAAM,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;UACxC;UACAN,mBAAmB,GAAGM,MAAM,CAACN,mBAAmB;UAChD,IAAI,CAACA,mBAAmB,EAAE;YACxB,MAAM,IAAIO,KAAK,CAAC,2DAA2D,CAAC;UAC9E;QACF,CAAC,MAAM;UACL;UACAP,mBAAmB,GAAGQ,OAAO,CAAC,yBAAyB,CAAC;QAC1D;;QAEA;QACAjB,SAAS,CAACkB,OAAO,GAAG,IAAIT,mBAAmB,CAAC;UAC1CZ,SAAS,EAAEA,SAAS,IAAI,qBAAqB;UAC7C,GAAGC;QACL,CAAC,CAAC;;QAEF;QACAE,SAAS,CAACkB,OAAO,CAACC,EAAE,CAAC,WAAW,EAAE,MAAM;UACtCN,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;UACnDZ,cAAc,CAAC,IAAI,CAAC;UACpBI,QAAQ,CAAC,IAAI,CAAC;QAChB,CAAC,CAAC;QAEFN,SAAS,CAACkB,OAAO,CAACC,EAAE,CAAC,OAAO,EAAGC,IAAI,IAAK;UACtCP,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;UAC9CV,UAAU,CAAC,IAAI,CAAC;UAChBI,aAAa,CAACY,IAAI,CAAC;QACrB,CAAC,CAAC;QAEFpB,SAAS,CAACkB,OAAO,CAACC,EAAE,CAAC,cAAc,EAAGC,IAAI,IAAK;UAC7CP,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;UACtDZ,cAAc,CAAC,KAAK,CAAC;UACrBE,UAAU,CAAC,KAAK,CAAC;UACjBE,QAAQ,CAAC,IAAIU,KAAK,CAAC,iBAAiBI,IAAI,CAACC,MAAM,EAAE,CAAC,CAAC;QACrD,CAAC,CAAC;QAEFrB,SAAS,CAACkB,OAAO,CAACC,EAAE,CAAC,OAAO,EAAGG,GAAG,IAAK;UACrCT,OAAO,CAACR,KAAK,CAAC,kCAAkC,EAAEiB,GAAG,CAAC;UACtDhB,QAAQ,CAACgB,GAAG,CAAC;QACf,CAAC,CAAC;QAEFtB,SAAS,CAACkB,OAAO,CAACC,EAAE,CAAC,6BAA6B,EAAE,MAAM;UACxDb,QAAQ,CAAC,IAAIU,KAAK,CAAC,+BAA+B,CAAC,CAAC;QACtD,CAAC,CAAC;;QAEF;QACA,MAAMhB,SAAS,CAACkB,OAAO,CAACK,OAAO,CAAC,CAAC;MAEnC,CAAC,CAAC,OAAOD,GAAG,EAAE;QACZT,OAAO,CAACR,KAAK,CAAC,gDAAgD,EAAEiB,GAAG,CAAC;QACpEhB,QAAQ,CAACgB,GAAG,CAAC;MACf;IACF,CAAC;IAEDZ,gBAAgB,CAAC,CAAC;;IAElB;IACA,OAAO,MAAM;MACX,IAAIV,SAAS,CAACkB,OAAO,EAAE;QACrBlB,SAAS,CAACkB,OAAO,CAACM,UAAU,CAAC,CAAC;MAChC;IACF,CAAC;EACH,CAAC,EAAE,CAAC3B,SAAS,CAAC,CAAC;EAEf,MAAM4B,YAAY,GAAG;IACnBC,MAAM,EAAE1B,SAAS,CAACkB,OAAO;IACzBjB,WAAW;IACXE,OAAO;IACPE,KAAK;IACLE;EACF,CAAC;EAED,oBACEd,OAAA,CAACC,oBAAoB,CAACiC,QAAQ;IAACC,KAAK,EAAEH,YAAa;IAAA7B,QAAA,EAChDA;EAAQ;IAAAiC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACoB,CAAC;AAEpC;;AAEA;AAAAjC,EAAA,CAlGgBJ,qBAAqB;AAAAsC,EAAA,GAArBtC,qBAAqB;AAmGrC,OAAO,SAASuC,gBAAgBA,CAAA,EAAG;EAAAC,GAAA;EACjC,MAAMC,OAAO,GAAG9C,UAAU,CAACI,oBAAoB,CAAC;EAEhD,IAAI,CAAC0C,OAAO,EAAE;IACZ,MAAM,IAAIpB,KAAK,CAAC,8DAA8D,CAAC;EACjF;EAEA,MAAM;IAAEU,MAAM;IAAEzB,WAAW;IAAEE,OAAO;IAAEE;EAAM,CAAC,GAAG+B,OAAO;;EAEvD;EACA,MAAM,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAGpD,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAM,CAACqD,SAAS,EAAEC,YAAY,CAAC,GAAGtD,QAAQ,CAAC,IAAI,CAAC;;EAEhD;EACA,MAAMuD,gBAAgB,GAAGpD,WAAW,CAAC,MAAOqD,SAAS,IAAK;IACxD,IAAI,CAAChB,MAAM,IAAI,CAACvB,OAAO,EAAE;MACvB,MAAM,IAAIa,KAAK,CAAC,4BAA4B,CAAC;IAC/C;IAEAsB,UAAU,CAAC,IAAI,CAAC;IAChBE,YAAY,CAAC,IAAI,CAAC;IAElB,IAAI;MACF,MAAMG,MAAM,GAAG,MAAMD,SAAS,CAAChB,MAAM,CAAC;MACtC,OAAOiB,MAAM;IACf,CAAC,CAAC,OAAOrB,GAAG,EAAE;MACZkB,YAAY,CAAClB,GAAG,CAAC;MACjB,MAAMA,GAAG;IACX,CAAC,SAAS;MACRgB,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EAAE,CAACZ,MAAM,EAAEvB,OAAO,CAAC,CAAC;;EAErB;EACA,MAAMyC,OAAO,GAAGvD,WAAW,CAAC,OAAOwD,UAAU,EAAEC,GAAG,EAAEhD,OAAO,GAAG,CAAC,CAAC,KAAK;IACnE,OAAO2C,gBAAgB,CAAC,MAAOf,MAAM,IAAK;MACxC,OAAO,MAAMA,MAAM,CAACqB,GAAG,CAACF,UAAU,EAAEC,GAAG,EAAEhD,OAAO,CAAC;IACnD,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC2C,gBAAgB,CAAC,CAAC;;EAEtB;EACA,MAAMO,OAAO,GAAG3D,WAAW,CAAC,OAAOwD,UAAU,EAAEC,GAAG,EAAElB,KAAK,EAAE9B,OAAO,GAAG,CAAC,CAAC,KAAK;IAC1E,OAAO2C,gBAAgB,CAAC,MAAOf,MAAM,IAAK;MACxC,OAAO,MAAMA,MAAM,CAACuB,GAAG,CAACJ,UAAU,EAAEC,GAAG,EAAElB,KAAK,EAAE9B,OAAO,CAAC;IAC1D,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC2C,gBAAgB,CAAC,CAAC;;EAEtB;EACA,MAAMS,UAAU,GAAG7D,WAAW,CAAC,OAAOwD,UAAU,EAAEC,GAAG,EAAEhD,OAAO,GAAG,CAAC,CAAC,KAAK;IACtE,OAAO2C,gBAAgB,CAAC,MAAOf,MAAM,IAAK;MACxC,OAAO,MAAMA,MAAM,CAACyB,MAAM,CAACN,UAAU,EAAEC,GAAG,EAAEhD,OAAO,CAAC;IACtD,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC2C,gBAAgB,CAAC,CAAC;;EAEtB;EACA,MAAMW,SAAS,GAAG/D,WAAW,CAAC,OAAOwD,UAAU,EAAEQ,KAAK,EAAEvD,OAAO,GAAG,CAAC,CAAC,KAAK;IACvE,OAAO2C,gBAAgB,CAAC,MAAOf,MAAM,IAAK;MACxC,OAAO,MAAMA,MAAM,CAAC2B,KAAK,CAACR,UAAU,EAAEQ,KAAK,EAAEvD,OAAO,CAAC;IACvD,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC2C,gBAAgB,CAAC,CAAC;;EAEtB;EACA,MAAMa,eAAe,GAAGjE,WAAW,CAAC,MAAOkE,UAAU,IAAK;IACxD,OAAOd,gBAAgB,CAAC,MAAOf,MAAM,IAAK;MACxC,OAAO,MAAMA,MAAM,CAAC8B,KAAK,CAACD,UAAU,CAAC;IACvC,CAAC,CAAC;EACJ,CAAC,EAAE,CAACd,gBAAgB,CAAC,CAAC;;EAEtB;EACA,MAAMgB,SAAS,GAAGpE,WAAW,CAAC,OAAOwD,UAAU,EAAEa,OAAO,EAAEC,QAAQ,KAAK;IACrE,IAAI,CAACjC,MAAM,IAAI,CAACvB,OAAO,EAAE;MACvB,MAAM,IAAIa,KAAK,CAAC,4BAA4B,CAAC;IAC/C;IACA,OAAO,MAAMU,MAAM,CAAC+B,SAAS,CAACZ,UAAU,EAAEa,OAAO,EAAEC,QAAQ,CAAC;EAC9D,CAAC,EAAE,CAACjC,MAAM,EAAEvB,OAAO,CAAC,CAAC;;EAErB;EACA,MAAMyD,WAAW,GAAGvE,WAAW,CAAC,OAAOwD,UAAU,EAAEa,OAAO,KAAK;IAC7D,IAAI,CAAChC,MAAM,IAAI,CAACvB,OAAO,EAAE;MACvB,MAAM,IAAIa,KAAK,CAAC,4BAA4B,CAAC;IAC/C;IACA,OAAO,MAAMU,MAAM,CAACkC,WAAW,CAACf,UAAU,EAAEa,OAAO,CAAC;EACtD,CAAC,EAAE,CAAChC,MAAM,EAAEvB,OAAO,CAAC,CAAC;EAErB,OAAO;IACL;IACAF,WAAW;IACXE,OAAO;IACPE,KAAK,EAAEA,KAAK,IAAIkC,SAAS;IACzBF,OAAO;IACPX,MAAM;IAEN;IACAkB,OAAO;IACPI,OAAO;IACPE,UAAU;IACVE,SAAS;IACTE,eAAe;IAEf;IACAG,SAAS;IACTG;EACF,CAAC;AACH;;AAEA;AAAAzB,GAAA,CAzGgBD,gBAAgB;AA0GhC,OAAO,SAAS2B,WAAWA,CAACC,MAAM,EAAE;EAAAC,GAAA;EAClC,MAAM;IAAEnB,OAAO;IAAEI,OAAO;IAAEE,UAAU;IAAEO,SAAS;IAAEG,WAAW;IAAEzD;EAAQ,CAAC,GAAG+B,gBAAgB,CAAC,CAAC;EAC5F,MAAM,CAAC8B,IAAI,EAAEC,OAAO,CAAC,GAAG/E,QAAQ,CAAC,IAAI,CAAC;EACtC,MAAM,CAACgF,WAAW,EAAEC,cAAc,CAAC,GAAGjF,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACkF,SAAS,EAAEC,YAAY,CAAC,GAAGnF,QAAQ,CAAC,IAAI,CAAC;;EAEhD;EACAC,SAAS,CAAC,MAAM;IACd,IAAIgB,OAAO,IAAI2D,MAAM,EAAE;MACrBQ,QAAQ,CAAC,CAAC;IACZ;EACF,CAAC,EAAE,CAACnE,OAAO,EAAE2D,MAAM,CAAC,CAAC;;EAErB;EACA3E,SAAS,CAAC,MAAM;IACd,IAAIgB,OAAO,IAAI2D,MAAM,EAAE;MACrB,MAAMS,gBAAgB,GAAIC,MAAM,IAAK;QACnC,IAAIA,MAAM,CAAC1B,GAAG,KAAKgB,MAAM,IAAIU,MAAM,CAAC9B,SAAS,KAAK,KAAK,EAAE;UACvDuB,OAAO,CAACO,MAAM,CAAC5C,KAAK,CAAC;UACrBf,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAE0D,MAAM,CAAC5C,KAAK,CAAC;QAChE;MACF,CAAC;MAED6B,SAAS,CAAC,MAAM,EAAEK,MAAM,EAAES,gBAAgB,CAAC,CAACE,KAAK,CAAC5D,OAAO,CAACR,KAAK,CAAC;MAEhE,OAAO,MAAM;QACXuD,WAAW,CAAC,MAAM,EAAEE,MAAM,CAAC,CAACW,KAAK,CAAC5D,OAAO,CAACR,KAAK,CAAC;MAClD,CAAC;IACH;EACF,CAAC,EAAE,CAACF,OAAO,EAAE2D,MAAM,EAAEL,SAAS,EAAEG,WAAW,CAAC,CAAC;EAE7C,MAAMU,QAAQ,GAAGjF,WAAW,CAAC,YAAY;IACvC,IAAI,CAACyE,MAAM,EAAE;IAEbK,cAAc,CAAC,IAAI,CAAC;IACpBE,YAAY,CAAC,IAAI,CAAC;IAElB,IAAI;MACF,MAAMK,QAAQ,GAAG,MAAM9B,OAAO,CAAC,MAAM,EAAEkB,MAAM,EAAE;QAAEa,YAAY,EAAE;MAAK,CAAC,CAAC;MACtEV,OAAO,CAACS,QAAQ,IAAI;QAAEE,KAAK,EAAE,EAAE;QAAEC,KAAK,EAAE;MAAE,CAAC,CAAC;IAC9C,CAAC,CAAC,OAAOxE,KAAK,EAAE;MACdQ,OAAO,CAACR,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MAC5CgE,YAAY,CAAChE,KAAK,CAAC;MACnB4D,OAAO,CAAC;QAAEW,KAAK,EAAE,EAAE;QAAEC,KAAK,EAAE;MAAE,CAAC,CAAC,CAAC,CAAC;IACpC,CAAC,SAAS;MACRV,cAAc,CAAC,KAAK,CAAC;IACvB;EACF,CAAC,EAAE,CAACL,MAAM,EAAElB,OAAO,CAAC,CAAC;EAErB,MAAMkC,QAAQ,GAAGzF,WAAW,CAAC,MAAOqF,QAAQ,IAAK;IAC/C,IAAI,CAACZ,MAAM,EAAE,MAAM,IAAI9C,KAAK,CAAC,kBAAkB,CAAC;IAEhDmD,cAAc,CAAC,IAAI,CAAC;IACpBE,YAAY,CAAC,IAAI,CAAC;IAElB,IAAI;MACF,MAAMrB,OAAO,CAAC,MAAM,EAAEc,MAAM,EAAEY,QAAQ,EAAE;QAAEC,YAAY,EAAE;MAAK,CAAC,CAAC;MAC/DV,OAAO,CAACS,QAAQ,CAAC;MACjB7D,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;IAC3C,CAAC,CAAC,OAAOT,KAAK,EAAE;MACdQ,OAAO,CAACR,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MAC5CgE,YAAY,CAAChE,KAAK,CAAC;MACnB,MAAMA,KAAK;IACb,CAAC,SAAS;MACR8D,cAAc,CAAC,KAAK,CAAC;IACvB;EACF,CAAC,EAAE,CAACL,MAAM,EAAEd,OAAO,CAAC,CAAC;EAErB,MAAM+B,SAAS,GAAG1F,WAAW,CAAC,YAAY;IACxC,IAAI,CAACyE,MAAM,EAAE,MAAM,IAAI9C,KAAK,CAAC,kBAAkB,CAAC;IAEhD,MAAMgE,SAAS,GAAG;MAAEJ,KAAK,EAAE,EAAE;MAAEC,KAAK,EAAE;IAAE,CAAC;IACzC,MAAMC,QAAQ,CAACE,SAAS,CAAC;EAC3B,CAAC,EAAE,CAAClB,MAAM,EAAEgB,QAAQ,CAAC,CAAC;EAEtB,MAAMG,SAAS,GAAG5F,WAAW,CAAC,MAAO6F,IAAI,IAAK;IAC5C,IAAI,CAAClB,IAAI,EAAE;IAEX,MAAMmB,iBAAiB,GAAGnB,IAAI,CAACY,KAAK,CAACQ,SAAS,CAACC,QAAQ,IAAIA,QAAQ,CAACC,EAAE,KAAKJ,IAAI,CAACI,EAAE,CAAC;IACnF,IAAIC,YAAY;IAEhB,IAAIJ,iBAAiB,IAAI,CAAC,EAAE;MAC1B;MACAI,YAAY,GAAG,CAAC,GAAGvB,IAAI,CAACY,KAAK,CAAC;MAC9BW,YAAY,CAACJ,iBAAiB,CAAC,GAAG;QAChC,GAAGI,YAAY,CAACJ,iBAAiB,CAAC;QAClCK,QAAQ,EAAED,YAAY,CAACJ,iBAAiB,CAAC,CAACK,QAAQ,IAAIN,IAAI,CAACM,QAAQ,IAAI,CAAC;MAC1E,CAAC;IACH,CAAC,MAAM;MACL;MACAD,YAAY,GAAG,CAAC,GAAGvB,IAAI,CAACY,KAAK,EAAE;QAAE,GAAGM,IAAI;QAAEM,QAAQ,EAAEN,IAAI,CAACM,QAAQ,IAAI;MAAE,CAAC,CAAC;IAC3E;IAEA,MAAMC,WAAW,GAAG;MAClB,GAAGzB,IAAI;MACPY,KAAK,EAAEW,YAAY;MACnBV,KAAK,EAAEU,YAAY,CAACG,MAAM,CAAC,CAACC,GAAG,EAAET,IAAI,KAAKS,GAAG,GAAIT,IAAI,CAACU,KAAK,GAAGV,IAAI,CAACM,QAAS,EAAE,CAAC;IACjF,CAAC;IAED,MAAMV,QAAQ,CAACW,WAAW,CAAC;EAC7B,CAAC,EAAE,CAACzB,IAAI,EAAEc,QAAQ,CAAC,CAAC;EAEpB,MAAMe,cAAc,GAAGxG,WAAW,CAAC,MAAOyG,MAAM,IAAK;IACnD,IAAI,CAAC9B,IAAI,EAAE;IAEX,MAAMuB,YAAY,GAAGvB,IAAI,CAACY,KAAK,CAACmB,MAAM,CAACb,IAAI,IAAIA,IAAI,CAACI,EAAE,KAAKQ,MAAM,CAAC;IAClE,MAAML,WAAW,GAAG;MAClB,GAAGzB,IAAI;MACPY,KAAK,EAAEW,YAAY;MACnBV,KAAK,EAAEU,YAAY,CAACG,MAAM,CAAC,CAACC,GAAG,EAAET,IAAI,KAAKS,GAAG,GAAIT,IAAI,CAACU,KAAK,GAAGV,IAAI,CAACM,QAAS,EAAE,CAAC;IACjF,CAAC;IAED,MAAMV,QAAQ,CAACW,WAAW,CAAC;EAC7B,CAAC,EAAE,CAACzB,IAAI,EAAEc,QAAQ,CAAC,CAAC;EAEpB,OAAO;IACLd,IAAI;IACJ3B,OAAO,EAAE6B,WAAW;IACpB7D,KAAK,EAAE+D,SAAS;IAChBE,QAAQ;IACRQ,QAAQ;IACRC,SAAS;IACTE,SAAS;IACTY;EACF,CAAC;AACH;;AAEA;AAAA9B,GAAA,CA/HgBF,WAAW;EAAA,QACiD3B,gBAAgB;AAAA;AA+H5F,OAAO,SAAS8D,cAAcA,CAAA,EAAG;EAAAC,GAAA;EAC/B,MAAM;IAAErD,OAAO;IAAEI,OAAO;IAAEE,UAAU;IAAE/C;EAAQ,CAAC,GAAG+B,gBAAgB,CAAC,CAAC;EACpE,MAAM,CAACgE,OAAO,EAAEC,UAAU,CAAC,GAAGjH,QAAQ,CAAC,IAAI,CAAC;EAC5C,MAAM,CAACkH,cAAc,EAAEC,iBAAiB,CAAC,GAAGnH,QAAQ,CAAC,KAAK,CAAC;EAC3D,MAAM,CAACoH,YAAY,EAAEC,eAAe,CAAC,GAAGrH,QAAQ,CAAC,IAAI,CAAC;EAEtD,MAAMsH,WAAW,GAAGnH,WAAW,CAAC,MAAOyE,MAAM,IAAK;IAChDuC,iBAAiB,CAAC,IAAI,CAAC;IACvBE,eAAe,CAAC,IAAI,CAAC;IAErB,IAAI;MACF,MAAME,WAAW,GAAG,MAAM7D,OAAO,CAAC,UAAU,EAAEkB,MAAM,CAAC;MACrDqC,UAAU,CAACM,WAAW,CAAC;MACvB,OAAOA,WAAW;IACpB,CAAC,CAAC,OAAOpG,KAAK,EAAE;MACdQ,OAAO,CAACR,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/CkG,eAAe,CAAClG,KAAK,CAAC;MACtB,OAAO,IAAI;IACb,CAAC,SAAS;MACRgG,iBAAiB,CAAC,KAAK,CAAC;IAC1B;EACF,CAAC,EAAE,CAACzD,OAAO,CAAC,CAAC;EAEb,MAAM8D,WAAW,GAAGrH,WAAW,CAAC,OAAOyE,MAAM,EAAE2C,WAAW,KAAK;IAC7DJ,iBAAiB,CAAC,IAAI,CAAC;IACvBE,eAAe,CAAC,IAAI,CAAC;IAErB,IAAI;MACF,MAAMvD,OAAO,CAAC,UAAU,EAAEc,MAAM,EAAE;QAChC,GAAG2C,WAAW;QACdE,WAAW,EAAEC,IAAI,CAACC,GAAG,CAAC;MACxB,CAAC,CAAC;MACFV,UAAU,CAACM,WAAW,CAAC;MACvB5F,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;IAC9C,CAAC,CAAC,OAAOT,KAAK,EAAE;MACdQ,OAAO,CAACR,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/CkG,eAAe,CAAClG,KAAK,CAAC;MACtB,MAAMA,KAAK;IACb,CAAC,SAAS;MACRgG,iBAAiB,CAAC,KAAK,CAAC;IAC1B;EACF,CAAC,EAAE,CAACrD,OAAO,CAAC,CAAC;EAEb,MAAM8D,YAAY,GAAGzH,WAAW,CAAC,MAAOyE,MAAM,IAAK;IACjD,IAAI;MACF,MAAMZ,UAAU,CAAC,UAAU,EAAEY,MAAM,CAAC;MACpCqC,UAAU,CAAC,IAAI,CAAC;MAChBtF,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;IACjD,CAAC,CAAC,OAAOT,KAAK,EAAE;MACdQ,OAAO,CAACR,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,CAAC6C,UAAU,CAAC,CAAC;EAEhB,OAAO;IACLgD,OAAO;IACP7D,OAAO,EAAE+D,cAAc;IACvB/F,KAAK,EAAEiG,YAAY;IACnBE,WAAW;IACXE,WAAW;IACXI,YAAY;IACZ3G;EACF,CAAC;AACH;;AAEA;AAAA8F,GAAA,CAjEgBD,cAAc;EAAA,QACsB9D,gBAAgB;AAAA;AAiEpE,OAAO,SAAS6E,WAAWA,CAACC,MAAM,EAAE;EAAAC,GAAA;EAClC,MAAM;IAAErE,OAAO;IAAEI,OAAO;IAAES,SAAS;IAAEG,WAAW;IAAEzD;EAAQ,CAAC,GAAG+B,gBAAgB,CAAC,CAAC;EAChF,MAAM,CAACgF,QAAQ,EAAEC,WAAW,CAAC,GAAGjI,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAACkI,WAAW,EAAEC,cAAc,CAAC,GAAGnI,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACoI,SAAS,EAAEC,YAAY,CAAC,GAAGrI,QAAQ,CAAC,IAAI,CAAC;;EAEhD;EACAC,SAAS,CAAC,MAAM;IACd,IAAIgB,OAAO,IAAI6G,MAAM,EAAE;MACrBQ,YAAY,CAAC,CAAC;IAChB;EACF,CAAC,EAAE,CAACrH,OAAO,EAAE6G,MAAM,CAAC,CAAC;;EAErB;EACA7H,SAAS,CAAC,MAAM;IACd,IAAIgB,OAAO,IAAI6G,MAAM,EAAE;MACrB,MAAMS,mBAAmB,GAAIjD,MAAM,IAAK;QACtC,IAAIA,MAAM,CAAC1B,GAAG,KAAKkE,MAAM,IAAIxC,MAAM,CAAC9B,SAAS,KAAK,KAAK,EAAE;UACvDyE,WAAW,CAAC3C,MAAM,CAAC5C,KAAK,IAAI,EAAE,CAAC;UAC/Bf,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;QACrD;MACF,CAAC;MAED2C,SAAS,CAAC,OAAO,EAAEuD,MAAM,EAAES,mBAAmB,CAAC,CAAChD,KAAK,CAAC5D,OAAO,CAACR,KAAK,CAAC;MAEpE,OAAO,MAAM;QACXuD,WAAW,CAAC,OAAO,EAAEoD,MAAM,CAAC,CAACvC,KAAK,CAAC5D,OAAO,CAACR,KAAK,CAAC;MACnD,CAAC;IACH;EACF,CAAC,EAAE,CAACF,OAAO,EAAE6G,MAAM,EAAEvD,SAAS,EAAEG,WAAW,CAAC,CAAC;EAE7C,MAAM4D,YAAY,GAAGnI,WAAW,CAAC,YAAY;IAC3C,IAAI,CAAC2H,MAAM,EAAE;IAEbK,cAAc,CAAC,IAAI,CAAC;IACpBE,YAAY,CAAC,IAAI,CAAC;IAElB,IAAI;MACF,MAAMG,WAAW,GAAG,MAAM9E,OAAO,CAAC,OAAO,EAAEoE,MAAM,EAAE;QACjDrC,YAAY,EAAE,IAAI;QAClBgD,SAAS,EAAE;MACb,CAAC,CAAC;MACFR,WAAW,CAACO,WAAW,IAAI,EAAE,CAAC;IAChC,CAAC,CAAC,OAAOrH,KAAK,EAAE;MACdQ,OAAO,CAACR,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChDkH,YAAY,CAAClH,KAAK,CAAC;MACnB8G,WAAW,CAAC,EAAE,CAAC;IACjB,CAAC,SAAS;MACRE,cAAc,CAAC,KAAK,CAAC;IACvB;EACF,CAAC,EAAE,CAACL,MAAM,EAAEpE,OAAO,CAAC,CAAC;EAErB,MAAMgF,WAAW,GAAGvI,WAAW,CAAC,MAAOwI,OAAO,IAAK;IACjD,IAAI,CAACb,MAAM,EAAE,MAAM,IAAIhG,KAAK,CAAC,kBAAkB,CAAC;IAEhD,MAAM8G,UAAU,GAAG;MACjBxC,EAAE,EAAE,OAAOsB,IAAI,CAACC,GAAG,CAAC,CAAC,IAAIkB,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;MAClElB,MAAM;MACNmB,OAAO,EAAEN,OAAO,CAACM,OAAO;MACxBC,QAAQ,EAAEP,OAAO,CAACO,QAAQ;MAC1BC,SAAS,EAAEzB,IAAI,CAACC,GAAG,CAAC,CAAC;MACrByB,IAAI,EAAET,OAAO,CAACS,IAAI,IAAI,MAAM;MAC5B,GAAGT;IACL,CAAC;IAED,MAAMU,eAAe,GAAG,CAAC,GAAGrB,QAAQ,EAAEY,UAAU,CAAC;IAEjD,IAAI;MACF,MAAM9E,OAAO,CAAC,OAAO,EAAEgE,MAAM,EAAEuB,eAAe,EAAE;QAC9C5D,YAAY,EAAE,IAAI;QAClBgD,SAAS,EAAE;MACb,CAAC,CAAC;MACF9G,OAAO,CAACC,GAAG,CAAC,8BAA8B,CAAC;IAC7C,CAAC,CAAC,OAAOT,KAAK,EAAE;MACdQ,OAAO,CAACR,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,CAAC2G,MAAM,EAAEE,QAAQ,EAAElE,OAAO,CAAC,CAAC;EAE/B,OAAO;IACLkE,QAAQ;IACR7E,OAAO,EAAE+E,WAAW;IACpB/G,KAAK,EAAEiH,SAAS;IAChBE,YAAY;IACZI;EACF,CAAC;AACH;AAACX,GAAA,CAtFeF,WAAW;EAAA,QACqC7E,gBAAgB;AAAA;AAuFhF,eAAeA,gBAAgB;AAAC,IAAAD,EAAA;AAAAuG,YAAA,CAAAvG,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}